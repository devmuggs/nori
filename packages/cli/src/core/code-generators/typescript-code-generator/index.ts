// goal of typescript code generate is to take a NoriState and produce code to easily let users interact with i18n in their projects

import logger from "../../logger.js";
import { NoriEntry, NoriManager } from "../../state-loader/index.js";
import {
	NoriEntryParamType,
	NoriLocale,
	NoriLocaleMeta
} from "../../state-loader/state-loader-types.js";

const IdStringToKeyString = (id: string): string => {
	const entryNameIndex = id.lastIndexOf(".");
	if (entryNameIndex !== -1) {
		id = id.substring(entryNameIndex + 1);
	}
	return `${id
		.replace(/[.\-_]/g, " ")
		.split(" ")
		.map((word, index) => {
			if (index === 0) return word.toLowerCase();
			return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
		})
		.join("")}`;
};

const ParamTypeToTsString: Record<NoriEntryParamType, string> = {
	[NoriEntryParamType.String]: "string",
	[NoriEntryParamType.Number]: "number",
	[NoriEntryParamType.Boolean]: "boolean"
} as const;

const stringWithTabs = (str: string, tabDepth: number): string => {
	const tabString = "\t".repeat(tabDepth);
	return `${tabString}${str.replace(/\n/g, `\n${tabString}`)}`;
};

const entryToTypeScript = (entry: NoriEntry, tabDepth: number): string => {
	const lines: string[] = [];
	const hasParams = entry.params && Object.values(entry.params).length > 0;
	if (entry.description) lines.push(stringWithTabs(`/** ${entry.description} */`, tabDepth));

	const declarationParts = [stringWithTabs(`${IdStringToKeyString(entry.id)}: (`, tabDepth)];

	// format parameters
	if (hasParams) {
		const paramsParts: string[] = [];

		for (const [paramKey, { type, description, default: defaultValue }] of Object.entries(
			entry.params
		)) {
			let paramLine = "";
			if (description) paramLine += `/** ${description} */\n`;

			const tsType = ParamTypeToTsString[type];
			if (!tsType)
				throw new Error(
					`Unsupported parameter type: ${type} for parameter ${paramKey} in entry ${entry.id}`
				);

			// if default value, include it in the declaration
			if (defaultValue !== undefined) {
				paramLine += `${paramKey}: ${tsType} | undefined`;
			} else {
				paramLine += `${paramKey}: ${tsType}`;
			}

			logger.debug(`Generated parameter line: ${paramLine}`);
			paramsParts.push(paramLine);
		}

		declarationParts.push(
			stringWithTabs(
				`\nparams: {\n${stringWithTabs(paramsParts.join(",\n"), tabDepth + 2)}\n}`,
				tabDepth + 1
			)
		);
	}

	declarationParts.push(stringWithTabs(`): NoriI18nCollection => {`, tabDepth));

	lines.push(stringWithTabs(declarationParts.join(" "), tabDepth));

	/*
    function body
    goal:
        const {paramName, paramNameWithDefault = defaultValue } = params;
        return {
            [NoriLocale.EnglishBritish]: "string with ${paramName} and ${paramNameWithDefault}",
            [NoriLocale.Japanese]: "string with ${paramName} in japanese"
        }
    note:
        - {{paramName}} in the original string should be converted to ${paramName} for template literals
    */
	const functionBodyLines: string[] = [];

	// destructure params
	const destructuredParamsParts: string[] = [];
	if (hasParams) {
		for (const [paramKey, { default: defaultValue }] of Object.entries(entry.params)) {
			if (defaultValue !== undefined) {
				destructuredParamsParts.push(`${paramKey} = ${JSON.stringify(defaultValue)}`);
			} else {
				destructuredParamsParts.push(paramKey);
			}
		}
		functionBodyLines.push(
			stringWithTabs(
				`const { ${destructuredParamsParts.join(", ")} } = params;`,
				tabDepth + 1
			)
		);
	}

	// return localized strings
	functionBodyLines.push(stringWithTabs(`return {`, tabDepth + 1));
	for (const localeKey of Object.values(NoriLocale)) {
		const localeString = entry.locales?.[localeKey] ?? `${entry.id} [${localeKey}]`;
		functionBodyLines.push(
			stringWithTabs(
				`[NoriLocale.${NoriLocaleMeta.reverseLookup(localeKey)}]: \`${localeString.replace(
					/{{\s*(\w+)\s*}}/g,
					"${$1}"
				)}\`,`,
				tabDepth + 2
			)
		);
	}
	functionBodyLines.push(stringWithTabs(`};`, tabDepth + 1));

	// add function body lines to main lines
	lines.push(...functionBodyLines);

	lines.push(stringWithTabs(`},`, tabDepth));
	return lines.join("\n");
};

export async function TypeScriptCodeGenerator(): Promise<string> {
	/** the nori manager */
	const lines: string[] = [];

	lines.push("// TypeScript code generated by Nori Code Generator");
	lines.push("");
	lines.push("import { NoriLocale, NoriI18nCollection } from '@nori/cli/core'");
	lines.push("");
	lines.push("export const nori = {");

	// iterate over collections

	for (const [collectionKey, collection] of NoriManager.collections) {
		if (collection.description) lines.push(`\t\t/** ${collection.description} */`);
		lines.push(`\t${collectionKey}: {`);

		// iterate over entries
		for (const [entryKey, entry] of collection.entries) {
			const entryCode = entryToTypeScript(entry, 2);
			lines.push(entryCode);
		}

		lines.push("\t} as const,");
	}

	lines.push("} as const;");
	const code = lines.join("\n");

	logger.info("Generated TypeScript Code:\n" + code);

	return code;
}

const myFunction = (num = 1 as 1 | 2): string => {
	return `Number is ${num}`;
};
